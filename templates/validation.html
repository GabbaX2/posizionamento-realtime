{% extends "base.html" %}

{% block title %}Validazione Step-by-Step con Calibrazione{% endblock %}

{% block content %}
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"
            crossorigin="anonymous"></script>

    <div class="grid grid-cols-1 lg:grid-cols-12 gap-8 relative">

        <div id="calibrationModal"
             class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/95 backdrop-blur-xl">
            <div class="bg-[#161831] border border-[#2e3054] p-6 rounded-2xl max-w-2xl w-full shadow-2xl relative flex flex-col items-center">
                <div class="w-full flex justify-between items-center mb-4">
                    <h3 class="text-2xl font-bold text-white flex items-center gap-2">
                        <i class="bi bi-magic text-indigo-400"></i> Calibrazione Sfondo
                    </h3>
                    <span class="text-xs font-mono text-slate-500 bg-slate-900 px-2 py-1 rounded">MediaPipe ML Active</span>
                </div>

                <p class="text-slate-300 text-center mb-6">
                    Posizionati in modo che la gamba sia chiaramente visibile.<br>
                    Lo sfondo viene rimosso digitalmente per verificare la qualità della ripresa.
                </p>

                <div class="relative w-full aspect-video bg-grid-pattern rounded-xl overflow-hidden border-2 border-indigo-500/50 shadow-[0_0_30px_rgba(79,70,229,0.3)] mb-6">
                    <canvas id="calibrationCanvas" class="w-full h-full object-contain"></canvas>

                    <div class="absolute bottom-3 left-0 right-0 flex justify-center pointer-events-none">
                        <div class="bg-black/70 backdrop-blur text-white px-4 py-1 rounded-full text-xs font-bold border border-white/10">
                            <i class="bi bi-eye-fill mr-1"></i> Anteprima Maschera AI
                        </div>
                    </div>
                </div>

                <div class="flex gap-4 w-full">
                    <button id="cancelCalibrationBtn"
                            class="flex-1 py-3 text-slate-400 hover:text-white hover:bg-slate-800 rounded-lg transition border border-transparent hover:border-slate-600">
                        Annulla
                    </button>
                    <button id="confirmCalibrationBtn"
                            class="flex-1 py-3 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 text-white rounded-lg font-bold shadow-lg transition flex items-center justify-center gap-2">
                        <i class="bi bi-check-circle-fill"></i> Conferma e Inizia
                    </button>
                </div>
            </div>
        </div>
        <div class="lg:col-span-8">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-2xl font-bold text-white tracking-tight">Validazione a Step</h2>
                <div class="flex gap-3">
                 <span id="stepStatus"
                       class="hidden px-3 py-1 rounded-full text-xs font-bold bg-indigo-600 text-white border border-indigo-400 shadow-[0_0_10px_rgba(79,70,229,0.5)]">
                    Step <span id="currentStepDisp">1</span> di <span id="totalStepsDisp">?</span>
                </span>
                    <span id="camStatus"
                          class="px-3 py-1 rounded-full text-xs font-semibold bg-slate-800 text-slate-400 border border-slate-700">Inizializzazione...</span>
                </div>
            </div>

            <div class="bg-black rounded-2xl overflow-hidden shadow-2xl border border-[#2e3054] relative group">
                <div class="video-container relative w-full bg-black aspect-video flex items-center justify-center">
                    <video id="videoElement" autoplay playsinline class="w-full h-full object-contain rounded"></video>
                    <canvas id="overlayCanvas" class="absolute top-0 left-0 w-full h-full pointer-events-none"></canvas>
                </div>

                <div class="accuracy-panel hidden absolute top-4 right-4 bg-gradient-to-r from-indigo-900/90 to-purple-900/90 backdrop-blur-md p-4 rounded-xl border border-indigo-500/30 transition-all duration-300 z-10"
                     id="accuracyPanel">
                    <div class="flex items-center gap-4">
                        <div class="relative w-16 h-16 flex-shrink-0">
                            <svg class="w-full h-full transform -rotate-90">
                                <circle cx="32" cy="32" r="28" stroke="currentColor" stroke-width="4" fill="transparent"
                                        class="text-slate-700"/>
                                <circle id="lockProgressRing" cx="32" cy="32" r="28" stroke="currentColor"
                                        stroke-width="4" fill="transparent"
                                        class="text-green-400 transition-all duration-200" stroke-dasharray="175"
                                        stroke-dashoffset="175"/>
                            </svg>
                            <div class="absolute inset-0 flex items-center justify-center">
                                <span class="text-sm font-bold text-white" id="accuracyValue">0%</span>
                            </div>
                        </div>
                        <div>
                            <h5 class="text-indigo-200 text-xs uppercase tracking-wider font-semibold mb-1"
                                id="groupActionText">Allineamento</h5>
                            <p class="text-lg font-bold text-white leading-tight mb-1" id="accuracyMessage">In
                                attesa...</p>
                        </div>
                    </div>
                </div>

                <div id="finalSuccessOverlay"
                     class="hidden absolute inset-0 bg-gradient-to-b from-black/90 to-green-900/60 backdrop-blur-md flex items-center justify-center z-30">
                    <div class="text-center p-8 bg-[#161831] border border-green-500/50 rounded-2xl shadow-2xl transform scale-110">
                        <i class="bi bi-trophy-fill text-6xl text-yellow-400 mb-4 inline-block drop-shadow-[0_0_15px_rgba(250,204,21,0.5)]"></i>
                        <h3 class="text-3xl font-bold text-white">Validazione Terminata</h3>
                        <p class="text-slate-300 mt-4 mb-6">Sessione conclusa manualmente.</p>
                        <button onclick="location.reload()"
                                class="px-6 py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-bold transition">
                            Nuova Sessione
                        </button>
                    </div>
                </div>
            </div>

            <div class="mt-6 flex flex-wrap gap-4 items-center bg-[#161831] p-4 rounded-xl border border-[#2e3054]">
                <button id="startBtn"
                        class="px-6 py-2.5 bg-green-600 hover:bg-green-700 text-white rounded-lg font-semibold shadow-lg shadow-green-900/20 transition-all flex items-center gap-2">
                    <i class="bi bi-play-fill text-xl"></i> Avvia
                </button>
                <button id="stopBtn"
                        class="px-6 py-2.5 bg-red-600 hover:bg-red-700 text-white rounded-lg font-semibold shadow-lg shadow-red-900/20 transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                        disabled>
                    <i class="bi bi-stop-fill text-xl"></i> Ferma
                </button>
                <div class="ml-auto flex items-center gap-4">
                    <button id="skipGroupBtn"
                            class="hidden text-slate-400 hover:text-white text-sm underline decoration-slate-600 underline-offset-4">
                        Salta Step <i class="bi bi-skip-forward-fill"></i>
                    </button>
                </div>
            </div>

            <div class="card mt-4 bg-[#161831] border border-[#2e3054] rounded-xl p-4">
                <label for="opacitySlider" class="text-sm text-slate-300 mb-2 block">
                    Opacità Overlay: <span id="opacityValue" class="text-indigo-400 font-bold">50</span>%
                </label>
                <input type="range"
                       class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-indigo-500"
                       id="opacitySlider" min="0" max="100" step="5" value="50">
            </div>
        </div>

        <div class="lg:col-span-4 space-y-6">
            <div class="bg-[#161831] border border-[#2e3054] rounded-2xl p-6">
                <h4 class="text-white font-semibold mb-4 flex items-center gap-2">
                    <i class="bi bi-image text-indigo-400"></i> Riferimento
                </h4>
                <div id="referencePreview">
                    <div class="text-center py-8 border-2 border-dashed border-slate-700 rounded-xl">
                        <h5 class="text-white mt-2 font-medium">Nessun Riferimento</h5>
                        <a href="/upload"
                           class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white text-sm rounded-lg transition inline-flex items-center mt-2">
                            <i class="bi bi-upload me-2"></i> Carica
                        </a>
                    </div>
                </div>
            </div>

            <div class="bg-[#161831] border border-[#2e3054] rounded-2xl p-6">
                <h5 class="text-white font-semibold mb-4 border-b border-[#2e3054] pb-2">Stato Sessione</h5>
                <div class="space-y-3">
                    <div class="flex justify-between items-center p-3 bg-[#0f1021] rounded-lg">
                        <strong class="text-slate-400 text-sm">Step Totali:</strong>
                        <span id="sessionTotalSteps" class="text-indigo-400 font-mono font-bold">-</span>
                    </div>
                    <div class="w-full bg-slate-800 rounded-full h-2.5 mt-2">
                        <div id="progressBar" class="bg-indigo-600 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block scripts %}
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>

    <script>
        // --- VARIABILI GLOBALI ---
        let cleanReferenceImage = null;
        let validationOverlayImage = null;
        let stepsConfig = null;
        let overlayOpacity = 0.5;

        let isCameraActive = false;
        let isValidating = false;
        let validationIntervalId = null;

        let currentStep = 1;
        let totalSteps = 1;

        // Smoothing UI
        let targetAccuracy = 0;
        let displayedAccuracy = 0;

        // Logica Step/Lock
        let lockTimer = 0;
        const LOCK_THRESHOLD = 85;
        const LOCK_DURATION = 1500;
        let sensorsRealtimeStatus = {};

        const video = document.getElementById('videoElement');
        const canvas = document.getElementById('overlayCanvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        const CIRCUMFERENCE = 175;

        // --- VARIABILI CALIBRAZIONE (MediaPipe) ---
        let selfieSegmentation = null;
        let isCalibrating = false;
        let calibrationReqId = null;
        const calibrationCanvas = document.getElementById('calibrationCanvas');
        const calCtx = calibrationCanvas ? calibrationCanvas.getContext('2d') : null;


        document.addEventListener('DOMContentLoaded', () => {
            loadSession();

            // MODIFICA: Il tasto Start ora lancia il processo di calibrazione
            document.getElementById('startBtn').onclick = startCalibrationProcess;

            document.getElementById('stopBtn').onclick = stopValidation;

            // Nuovi pulsanti Modale
            document.getElementById('confirmCalibrationBtn').onclick = confirmCalibrationAndStart;
            document.getElementById('cancelCalibrationBtn').onclick = closeCalibration;

            document.getElementById('opacitySlider').oninput = (e) => {
                overlayOpacity = e.target.value / 100;
                document.getElementById('opacityValue').innerText = e.target.value;
            };
            const skipBtn = document.getElementById('skipGroupBtn');
            if (skipBtn) skipBtn.onclick = () => nextStep();

            const uploadLink = document.querySelector('a[href="/upload"]');
            if (uploadLink) {
                uploadLink.onclick = (e) => {
                    e.preventDefault();
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.onchange = (ev) => handleFileUpload(ev.target.files[0]);
                    input.click();
                };
            }

            requestAnimationFrame(animateValues);
        });

        // ---------------------------------------------
        // 1. LOGICA DI CALIBRAZIONE (MediaPipe)
        // ---------------------------------------------

        async function initMediaPipe() {
            if (selfieSegmentation) return;

            console.log("Inizializzazione MediaPipe...");
            selfieSegmentation = new SelfieSegmentation({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`;
                }
            });

            selfieSegmentation.setOptions({
                modelSelection: 1, // 1 = Landscape (Più lento ma più preciso), 0 = General
                selfieMode: false,
            });

            selfieSegmentation.onResults(onCalibrationResults);
        }

        async function startCalibrationProcess() {
            // Assicuriamoci che la camera sia attiva prima
            if (!isCameraActive) {
                await initCamera();
            }

            // Inizializza AI
            await initMediaPipe();

            // Mostra UI
            document.getElementById('calibrationModal').classList.remove('hidden');
            isCalibrating = true;

            // Avvia loop di calibrazione
            const processCalibrationFrame = async () => {
                if (!isCalibrating) return;

                if (video.readyState >= 2) { // 2 = HAVE_CURRENT_DATA
                    await selfieSegmentation.send({image: video});
                }
                calibrationReqId = requestAnimationFrame(processCalibrationFrame);
            };
            processCalibrationFrame();
        }

        function onCalibrationResults(results) {
            if (!isCalibrating || !calCtx) return;

            // Imposta dimensioni
            calibrationCanvas.width = results.image.width;
            calibrationCanvas.height = results.image.height;

            calCtx.save();
            calCtx.clearRect(0, 0, calibrationCanvas.width, calibrationCanvas.height);

            // 1. Disegna la maschera (sagoma bianca su nero)
            calCtx.drawImage(results.segmentationMask, 0, 0, calibrationCanvas.width, calibrationCanvas.height);

            // 2. 'source-in': mantiene i nuovi disegni (immagine webcam) SOLO dove c'è già qualcosa (la maschera bianca)
            // Questo taglia via lo sfondo
            calCtx.globalCompositeOperation = 'source-in';
            calCtx.drawImage(results.image, 0, 0, calibrationCanvas.width, calibrationCanvas.height);

            // 3. 'destination-over': disegna dietro a tutto ciò che esiste (lo sfondo nero)
            calCtx.globalCompositeOperation = 'destination-over';
            calCtx.fillStyle = '#000000'; // Colore sfondo oscurato
            calCtx.fillRect(0, 0, calibrationCanvas.width, calibrationCanvas.height);

            calCtx.restore();
        }

        function closeCalibration() {
            isCalibrating = false;
            if (calibrationReqId) cancelAnimationFrame(calibrationReqId);
            document.getElementById('calibrationModal').classList.add('hidden');
        }

        function confirmCalibrationAndStart() {
            // Utente soddisfatto della calibrazione/inquadratura
            closeCalibration();

            // Avvia la validazione vera
            realStartValidation();
        }


        // ---------------------------------------------
        // 2. GESTIONE UPLOAD E SESSIONE
        // ---------------------------------------------

        async function handleFileUpload(file) {
            if (!file) return;
            const formData = new FormData();
            formData.append('file', file);
            document.getElementById('referencePreview').innerHTML = `<div class="text-white animate-pulse">Caricamento...</div>`;

            try {
                const response = await fetch('/upload', {method: 'POST', body: formData});
                const data = await response.json();

                if (data.success) {
                    localStorage.setItem('cleanReferenceImage', `data:image/png;base64,${data.reference_image}`);
                    localStorage.setItem('validationOverlayImage', `data:image/png;base64,${data.drawing_overlay_image}`);
                    localStorage.setItem('referenceMetadata', JSON.stringify(data));

                    loadSession(); // Ricarica variabili
                    alert(`Upload OK: ${data.message}`);
                } else {
                    alert("Errore: " + data.error);
                }
            } catch (e) {
                alert("Errore di rete");
            }
        }

        function loadSession() {
            const refSrc = localStorage.getItem('cleanReferenceImage');
            const ovlSrc = localStorage.getItem('validationOverlayImage');
            const meta = localStorage.getItem('referenceMetadata');

            if (refSrc && ovlSrc && meta) {
                cleanReferenceImage = new Image();
                cleanReferenceImage.src = refSrc;
                validationOverlayImage = new Image();
                validationOverlayImage.src = ovlSrc;
                let metadata;
                try {
                    metadata = JSON.parse(meta);
                } catch (e) {
                    return;
                }

                stepsConfig = metadata.steps_config || {};
                const dictLen = Object.keys(stepsConfig).length;
                const listLen = metadata.sensors_data ? Math.ceil(metadata.sensors_data.length / 2) : 1;
                totalSteps = Math.max(dictLen, listLen, metadata.total_steps || 1);

                document.getElementById('totalStepsDisp').innerText = totalSteps;
                document.getElementById('sessionTotalSteps').innerText = totalSteps;
                document.getElementById('referencePreview').innerHTML = `<img src="${ovlSrc}" class="w-3/4 mx-auto rounded border border-slate-600">`;

                validationOverlayImage.onload = () => {
                    // Non avviamo la camera subito, aspettiamo il click o la calibrazione
                    // ma ridimensioniamo per sicurezza
                    resizeCanvas();
                };
                document.getElementById('startBtn').disabled = false;
            }
        }

        async function initCamera() {
            if (isCameraActive || !window.sensorApp) return;
            // Assumi che window.sensorApp esista dal file js/main.js incluso
            await window.sensorApp.initializeCameraWithAdaptiveResolution(null, validationOverlayImage);
            isCameraActive = true;
            document.getElementById('camStatus').innerText = "Camera OK";
            document.getElementById('camStatus').className = "px-3 py-1 rounded-full text-xs font-semibold bg-green-900 text-green-200 border border-green-700";
            requestAnimationFrame(drawLoop);
        }

        // ---------------------------------------------
        // 3. LOGICA VALIDAZIONE (CORE)
        // ---------------------------------------------

        function realStartValidation() {
            if (!isCameraActive) return;
            isValidating = true;
            currentStep = 1;
            lockTimer = 0;
            updateUI();

            document.getElementById('stepStatus').classList.remove('hidden');
            document.getElementById('skipGroupBtn').classList.remove('hidden');
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;

            // Loop per inviare frame al backend (ogni 500ms)
            validationIntervalId = setInterval(validateBackend, 500);
        }

        function stopValidation() {
            isValidating = false;
            clearInterval(validationIntervalId);
            document.getElementById('accuracyPanel').classList.add('hidden');
            document.getElementById('stepStatus').classList.add('hidden');
            document.getElementById('skipGroupBtn').classList.add('hidden');

            document.getElementById('finalSuccessOverlay').classList.remove('hidden');
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        async function validateBackend() {
            if (!isValidating) return;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            tempCanvas.getContext('2d').drawImage(video, 0, 0);

            // Nota: Inviamo l'immagine normale. Se volessi inviare quella ritagliata,
            // dovresti usare selfieSegmentation qui dentro, ma rallenterebbe molto.
            // La calibrazione iniziale serve a garantire che l'immagine normale sia buona.
            const frame = tempCanvas.toDataURL('image/jpeg', 0.6);
            const meta = JSON.parse(localStorage.getItem('referenceMetadata'));

            try {
                const res = await fetch('/api/validate_frame', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        session_id: meta ? meta.session_id : 'default',
                        reference_image: cleanReferenceImage.src,
                        current_frame: frame,
                        current_step: currentStep
                    })
                });
                const data = await res.json();

                if (data.success) {
                    targetAccuracy = data.accuracy; // Per animazione
                    document.getElementById('accuracyMessage').innerText = data.message;
                    document.getElementById('accuracyPanel').classList.remove('hidden');

                    if (data.sensors_status) {
                        data.sensors_status.forEach(s => sensorsRealtimeStatus[s.id] = s.present);
                    }

                    // Logica Timer Lock (per ora solo visiva se manuale)
                    if (displayedAccuracy >= LOCK_THRESHOLD) {
                        lockTimer += 500;
                    } else {
                        lockTimer = 0;
                    }
                }
            } catch (e) {
                console.error(e);
            }
        }

        function nextStep() {
            lockTimer = 0;
            currentStep++;
            if (currentStep > totalSteps) {
                isValidating = false;
                clearInterval(validationIntervalId);
                document.getElementById('accuracyMessage').innerText = "Finito. Premi STOP.";
            } else {
                updateUI();
            }
        }

        // ---------------------------------------------
        // 4. RENDERING GRAFICO (Overlay, UI)
        // ---------------------------------------------

        function animateValues() {
            if (Math.abs(targetAccuracy - displayedAccuracy) > 0.5) {
                displayedAccuracy += (targetAccuracy - displayedAccuracy) * 0.1;
            } else {
                displayedAccuracy = targetAccuracy;
            }
            const finalVal = Math.round(displayedAccuracy);
            const accValEl = document.getElementById('accuracyValue');
            if (accValEl) accValEl.innerText = finalVal + '%';

            const progress = Math.min(finalVal / 100, 1);
            const offset = CIRCUMFERENCE - (progress * CIRCUMFERENCE);
            const ring = document.getElementById('lockProgressRing');
            if (ring) ring.style.strokeDashoffset = offset;

            requestAnimationFrame(animateValues);
        }

        function drawLoop() {
            if (!isCameraActive) return;
            resizeCanvas();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Disegna Overlay di Riferimento (trasparente)
            ctx.globalAlpha = overlayOpacity;
            const dims = getDrawDimensions();
            if (validationOverlayImage) ctx.drawImage(validationOverlayImage, dims.x, dims.y, dims.w, dims.h);

            // Disegna Indicatori Step/Sensori
            if (isValidating && stepsConfig) {
                const scale = dims.w / validationOverlayImage.naturalWidth;
                const isGlobalSuccess = displayedAccuracy >= 85;

                Object.keys(stepsConfig).forEach(stepKey => {
                    const stepNum = parseInt(stepKey);
                    const sensorsInStep = stepsConfig[stepKey];

                    sensorsInStep.forEach(s => {
                        const cx = dims.x + (s.x * scale);
                        const cy = dims.y + (s.y * scale);
                        const r = s.r * scale;
                        const isPresent = sensorsRealtimeStatus[s.id];

                        ctx.lineWidth = 5;

                        if (stepNum < currentStep) {
                            // Step Passati
                            ctx.globalAlpha = 0.7;
                            ctx.strokeStyle = '#22c55e';
                            ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
                            ctx.beginPath();
                            ctx.arc(cx, cy, r, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                            ctx.fillStyle = '#fff';
                            ctx.font = 'bold 20px Arial';
                            ctx.fillText("✓", cx - 7, cy + 7);
                        } else if (stepNum === currentStep) {
                            // Step Corrente
                            ctx.globalAlpha = 1.0;
                            if (isPresent || isGlobalSuccess) {
                                // Successo (Verde Neon)
                                ctx.shadowBlur = 30;
                                ctx.shadowColor = '#00FF00';
                                ctx.strokeStyle = '#00FF00';
                                ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                                ctx.beginPath();
                                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.stroke();
                                ctx.shadowBlur = 0;
                                ctx.fillStyle = '#fff';
                                ctx.font = 'bold 16px Arial';
                                ctx.fillText(s.id, cx - 5, cy + 5);
                            } else {
                                // Mancante (Rosso Pulsante)
                                const pulse = 1 + Math.sin(Date.now() / 150) * 0.15;
                                ctx.strokeStyle = '#FF0000';
                                ctx.shadowBlur = 25;
                                ctx.shadowColor = '#FF0000';
                                ctx.beginPath();
                                ctx.arc(cx, cy, r * pulse, 0, Math.PI * 2);
                                ctx.stroke();
                                ctx.shadowBlur = 0;
                                ctx.fillStyle = '#FF0000';
                                ctx.font = 'bold 14px Arial';
                                ctx.fillText("MANCA", cx - 25, cy - r - 10);
                            }
                        } else {
                            // Step Futuri
                            ctx.globalAlpha = 0.3;
                            ctx.strokeStyle = '#94a3b8';
                            ctx.beginPath();
                            ctx.arc(cx, cy, r, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    });
                });
            }
            requestAnimationFrame(drawLoop);
        }

        function updateUI() {
            const safeStep = currentStep > totalSteps ? totalSteps : currentStep;
            document.getElementById('currentStepDisp').innerText = safeStep;
            const pct = ((safeStep - 1) / totalSteps) * 100;
            document.getElementById('progressBar').style.width = pct + '%';
        }

        function getDrawDimensions() {
            if (!validationOverlayImage) return {x: 0, y: 0, w: 0, h: 0};
            const iw = validationOverlayImage.naturalWidth;
            const ih = validationOverlayImage.naturalHeight;
            const cw = canvas.width;
            const ch = canvas.height;
            const scale = Math.min(cw / iw, ch / ih);
            const w = iw * scale;
            const h = ih * scale;
            return {x: (cw - w) / 2, y: (ch - h) / 2, w: w, h: h};
        }

        function resizeCanvas() {
            if (video) {
                canvas.width = video.clientWidth;
                canvas.height = video.clientHeight;
            }
        }
    </script>
{% endblock %}