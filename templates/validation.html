{% extends "base.html" %}

{% block title %}Validazione Step-by-Step{% endblock %}

{% block content %}
    <div class="grid grid-cols-1 lg:grid-cols-12 gap-8 relative">

        <div class="lg:col-span-8">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-2xl font-bold text-white tracking-tight">Validazione a Step</h2>
                <div class="flex gap-3">
                 <span id="stepStatus"
                       class="hidden px-3 py-1 rounded-full text-xs font-bold bg-indigo-600 text-white border border-indigo-400 shadow-[0_0_10px_rgba(79,70,229,0.5)]">
                    Step <span id="currentStepDisp">1</span> di <span id="totalStepsDisp">?</span>
                </span>
                    <span id="camStatus"
                          class="px-3 py-1 rounded-full text-xs font-semibold bg-slate-800 text-slate-400 border border-slate-700">Inizializzazione...</span>
                </div>
            </div>

            <div class="bg-black rounded-2xl overflow-hidden shadow-2xl border border-[#2e3054] relative group">
                <div class="video-container relative w-full bg-black aspect-video flex items-center justify-center">
                    <video id="videoElement" autoplay playsinline class="w-full h-full object-contain rounded"></video>
                    <canvas id="overlayCanvas" class="absolute top-0 left-0 w-full h-full pointer-events-none"></canvas>
                </div>

                <div class="accuracy-panel hidden absolute top-4 right-4 bg-gradient-to-r from-indigo-900/90 to-purple-900/90 backdrop-blur-md p-4 rounded-xl border border-indigo-500/30 transition-all duration-300 z-10"
                     id="accuracyPanel">
                    <div class="flex items-center gap-4">
                        <div class="relative w-16 h-16 flex-shrink-0">
                            <svg class="w-full h-full transform -rotate-90">
                                <circle cx="32" cy="32" r="28" stroke="currentColor" stroke-width="4" fill="transparent"
                                        class="text-slate-700"/>
                                <circle id="lockProgressRing" cx="32" cy="32" r="28" stroke="currentColor"
                                        stroke-width="4" fill="transparent"
                                        class="text-green-400 transition-all duration-200" stroke-dasharray="175"
                                        stroke-dashoffset="175"/>
                            </svg>
                            <div class="absolute inset-0 flex items-center justify-center">
                                <span class="text-sm font-bold text-white" id="accuracyValue">0%</span>
                            </div>
                        </div>
                        <div>
                            <h5 class="text-indigo-200 text-xs uppercase tracking-wider font-semibold mb-1"
                                id="groupActionText">Allineamento</h5>
                            <p class="text-lg font-bold text-white leading-tight mb-1" id="accuracyMessage">In
                                attesa...</p>
                        </div>
                    </div>
                </div>

                <div id="finalSuccessOverlay"
                     class="hidden absolute inset-0 bg-gradient-to-b from-black/90 to-green-900/60 backdrop-blur-md flex items-center justify-center z-30">
                    <div class="text-center p-8 bg-[#161831] border border-green-500/50 rounded-2xl shadow-2xl transform scale-110">
                        <i class="bi bi-trophy-fill text-6xl text-yellow-400 mb-4 inline-block drop-shadow-[0_0_15px_rgba(250,204,21,0.5)]"></i>
                        <h3 class="text-3xl font-bold text-white">Validazione Terminata</h3>
                        <p class="text-slate-300 mt-4 mb-6">Tutti gli step completati o interrotti.</p>
                        <button onclick="location.reload()"
                                class="px-6 py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-bold transition">
                            Nuova Sessione
                        </button>
                    </div>
                </div>
            </div>

            <div class="mt-6 flex flex-wrap gap-4 items-center bg-[#161831] p-4 rounded-xl border border-[#2e3054]">
                <button id="startBtn"
                        class="px-6 py-2.5 bg-green-600 hover:bg-green-700 text-white rounded-lg font-semibold shadow-lg shadow-green-900/20 transition-all flex items-center gap-2">
                    <i class="bi bi-play-fill text-xl"></i> Avvia
                </button>
                <button id="stopBtn"
                        class="px-6 py-2.5 bg-red-600 hover:bg-red-700 text-white rounded-lg font-semibold shadow-lg shadow-red-900/20 transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                        disabled>
                    <i class="bi bi-stop-fill text-xl"></i> Ferma
                </button>
                <div class="ml-auto flex items-center gap-4">
                    <button id="skipGroupBtn"
                            class="hidden text-slate-400 hover:text-white text-sm underline decoration-slate-600 underline-offset-4">
                        Salta Step <i class="bi bi-skip-forward-fill"></i>
                    </button>
                </div>
            </div>

            <div class="card mt-4 bg-[#161831] border border-[#2e3054] rounded-xl p-4">
                <label for="opacitySlider" class="text-sm text-slate-300 mb-2 block">
                    Opacità Guida: <span id="opacityValue" class="text-indigo-400 font-bold">50</span>%
                </label>
                <input type="range"
                       class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-indigo-500"
                       id="opacitySlider" min="0" max="100" step="5" value="50">
            </div>
        </div>

        <div class="lg:col-span-4 space-y-6">
            <div class="bg-[#161831] border border-[#2e3054] rounded-2xl p-6">
                <h4 class="text-white font-semibold mb-4 flex items-center gap-2">
                    <i class="bi bi-image text-indigo-400"></i> Riferimento
                </h4>
                <div id="referencePreview">
                    <div class="text-center py-8 border-2 border-dashed border-slate-700 rounded-xl">
                        <h5 class="text-white mt-2 font-medium">Nessun Riferimento</h5>
                        <a href="/upload"
                           class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white text-sm rounded-lg transition inline-flex items-center mt-2">
                            <i class="bi bi-upload me-2"></i> Carica
                        </a>
                    </div>
                </div>
            </div>

            <div class="bg-[#161831] border border-[#2e3054] rounded-2xl p-6">
                <h5 class="text-white font-semibold mb-4 border-b border-[#2e3054] pb-2">Stato Sessione</h5>
                <div class="space-y-3">
                    <div class="flex justify-between items-center p-3 bg-[#0f1021] rounded-lg">
                        <strong class="text-slate-400 text-sm">Step Totali:</strong>
                        <span id="sessionTotalSteps" class="text-indigo-400 font-mono font-bold">-</span>
                    </div>
                    <div class="w-full bg-slate-800 rounded-full h-2.5 mt-2">
                        <div id="progressBar" class="bg-indigo-600 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block scripts %}
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>

    <script>
        // --- VARIABILI GLOBALI ---
        let cleanReferenceImage = null;
        let validationOverlayImage = null; // Maschera bordi (Bianco su Nero)
        let stepsConfig = null;
        let overlayOpacity = 0.5;

        let isCameraActive = false;
        let isValidating = false;
        let validationIntervalId = null;

        let currentStep = 1;
        let totalSteps = 1;

        // Variabili Smoothing UI
        let targetAccuracy = 0;
        let displayedAccuracy = 0;
        let sensorsRealtimeStatus = {};

        const video = document.getElementById('videoElement');
        const canvas = document.getElementById('overlayCanvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        const CIRCUMFERENCE = 175; // Per l'animazione SVG

        document.addEventListener('DOMContentLoaded', () => {
            loadSession();

            // Setup Bottoni
            document.getElementById('startBtn').onclick = startValidation;
            document.getElementById('stopBtn').onclick = stopValidation;

            // Slider Opacità
            document.getElementById('opacitySlider').oninput = (e) => {
                overlayOpacity = e.target.value / 100;
                document.getElementById('opacityValue').innerText = e.target.value;
            };

            // Bottone Salta Step
            const skipBtn = document.getElementById('skipGroupBtn');
            if (skipBtn) skipBtn.onclick = () => nextStep();

            // Link Upload (se presente)
            const uploadLink = document.querySelector('a[href="/upload"]');
            if (uploadLink) {
                uploadLink.onclick = (e) => {
                    e.preventDefault();
                    window.location.href = '/upload';
                };
            }

            // Avvio Loop Animazione UI
            requestAnimationFrame(animateValues);
        });

        // ---------------------------------------------
        // 1. CARICAMENTO SESSIONE & CAMERA
        // ---------------------------------------------

        function loadSession() {
            const refSrc = localStorage.getItem('cleanReferenceImage');
            const ovlSrc = localStorage.getItem('validationOverlayImage');
            const meta = localStorage.getItem('referenceMetadata');

            if (refSrc && ovlSrc && meta) {
                cleanReferenceImage = new Image();
                cleanReferenceImage.src = refSrc;

                validationOverlayImage = new Image();
                validationOverlayImage.src = ovlSrc;

                let metadata;
                try {
                    metadata = JSON.parse(meta);
                } catch (e) {
                    return;
                }

                stepsConfig = metadata.steps_config || {};
                const dictLen = Object.keys(stepsConfig).length;
                totalSteps = dictLen > 0 ? dictLen : 1;

                document.getElementById('totalStepsDisp').innerText = totalSteps;
                document.getElementById('sessionTotalSteps').innerText = totalSteps;

                // Anteprima piccola del riferimento
                document.getElementById('referencePreview').innerHTML = `
                    <div class="bg-black p-2 rounded border border-slate-700">
                        <img src="${ovlSrc}" class="w-full h-auto opacity-80" alt="Riferimento">
                    </div>`;

                // Quando l'immagine di overlay è pronta, avviamo la camera
                validationOverlayImage.onload = () => {
                    initCamera();
                };
                document.getElementById('startBtn').disabled = false;
            }
        }

        async function initCamera() {
            if (isCameraActive || !window.sensorApp) return;
            // Usa il metodo esistente in main.js
            await window.sensorApp.initializeCameraWithAdaptiveResolution(null, validationOverlayImage);
            isCameraActive = true;

            document.getElementById('camStatus').innerText = "Camera OK";
            document.getElementById('camStatus').className = "px-3 py-1 rounded-full text-xs font-semibold bg-green-900 text-green-200 border border-green-700";

            // Avvia il loop di disegno sul canvas
            requestAnimationFrame(drawLoop);
        }

        // ---------------------------------------------
        // 2. LOGICA VALIDAZIONE
        // ---------------------------------------------

        function startValidation() {
            if (!isCameraActive) return;
            isValidating = true;
            currentStep = 1;
            updateUI();

            // Aggiorna UI Bottoni
            document.getElementById('stepStatus').classList.remove('hidden');
            document.getElementById('skipGroupBtn').classList.remove('hidden');
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;

            // Avvia il polling al backend
            validationIntervalId = setInterval(validateBackend, 500);
        }

        function stopValidation() {
            isValidating = false;
            clearInterval(validationIntervalId);

            // Nascondi pannelli attivi
            document.getElementById('accuracyPanel').classList.add('hidden');
            document.getElementById('stepStatus').classList.add('hidden');
            document.getElementById('skipGroupBtn').classList.add('hidden');

            // Mostra overlay finale
            document.getElementById('finalSuccessOverlay').classList.remove('hidden');

            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        async function validateBackend() {
            if (!isValidating) return;

            // Cattura frame corrente dal video
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            tempCanvas.getContext('2d').drawImage(video, 0, 0);

            // Frame JPEG leggero
            const frame = tempCanvas.toDataURL('image/jpeg', 0.6);
            const meta = JSON.parse(localStorage.getItem('referenceMetadata'));

            try {
                const res = await fetch('/api/validate_frame', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        session_id: meta ? meta.session_id : 'default',
                        current_frame: frame,
                        current_step: currentStep
                    })
                });
                const data = await res.json();

                if (data.success) {
                    targetAccuracy = data.accuracy; // Per animazione fluida

                    document.getElementById('accuracyMessage').innerText = data.message;
                    document.getElementById('groupActionText').innerText = data.direction || "Allineamento";
                    document.getElementById('accuracyPanel').classList.remove('hidden');

                    // Aggiorna stato sensori
                    if (data.sensors_status) {
                        data.sensors_status.forEach(s => sensorsRealtimeStatus[s.id] = s.present);
                    }
                }
            } catch (e) {
                console.error(e);
            }
        }

        function nextStep() {
            currentStep++;
            if (currentStep > totalSteps) {
                stopValidation();
            } else {
                updateUI();
            }
        }

        // ---------------------------------------------
        // 3. RENDERING & ANIMAZIONI
        // ---------------------------------------------

        function animateValues() {
            // Interpolazione lineare per il valore percentuale (effetto fluido)
            if (Math.abs(targetAccuracy - displayedAccuracy) > 0.5) {
                displayedAccuracy += (targetAccuracy - displayedAccuracy) * 0.1;
            } else {
                displayedAccuracy = targetAccuracy;
            }

            // Aggiorna testo
            document.getElementById('accuracyValue').innerText = Math.round(displayedAccuracy) + '%';

            // Aggiorna anello progresso
            const progress = Math.min(Math.round(displayedAccuracy) / 100, 1);
            const offset = CIRCUMFERENCE - (progress * CIRCUMFERENCE);
            document.getElementById('lockProgressRing').style.strokeDashoffset = offset;

            requestAnimationFrame(animateValues);
        }

        function drawLoop() {
            if (!isCameraActive) return;
            resizeCanvas();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Disegna Overlay Guida (Fondamentale per allineamento manuale)
            ctx.globalAlpha = overlayOpacity;
            const dims = getDrawDimensions(canvas.width, canvas.height, validationOverlayImage);

            // Disegniamo il riferimento (linee bianche)
            if (validationOverlayImage) {
                ctx.drawImage(validationOverlayImage, dims.x, dims.y, dims.w, dims.h);
            }

            // 2. Disegna Indicatori Step (Sensori)
            if (isValidating && stepsConfig) {
                const scale = dims.w / validationOverlayImage.naturalWidth;

                Object.keys(stepsConfig).forEach(stepKey => {
                    const stepNum = parseInt(stepKey);
                    const sensors = stepsConfig[stepKey];

                    sensors.forEach(s => {
                        const cx = dims.x + (s.x * scale);
                        const cy = dims.y + (s.y * scale);
                        const r = s.r * scale;
                        const isPresent = sensorsRealtimeStatus[s.id];

                        ctx.lineWidth = 3;

                        if (stepNum < currentStep) {
                            // Step Passati (Verde scuro/trasparente)
                            ctx.globalAlpha = 0.5;
                            ctx.strokeStyle = '#22c55e';
                            ctx.beginPath();
                            ctx.arc(cx, cy, r, 0, Math.PI * 2);
                            ctx.stroke();
                        } else if (stepNum === currentStep) {
                            // Step Corrente
                            ctx.globalAlpha = 1.0;
                            if (isPresent) {
                                // Trovato (Verde Neon)
                                ctx.strokeStyle = '#00FF00';
                                ctx.shadowBlur = 15;
                                ctx.shadowColor = '#00FF00';
                                ctx.beginPath();
                                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                                ctx.stroke();
                                ctx.shadowBlur = 0;
                            } else {
                                // In attesa / Non trovato (Giallo/Grigio)
                                if (displayedAccuracy < 50) {
                                    // Se non allineato, grigio
                                    ctx.strokeStyle = '#94a3b8';
                                } else {
                                    // Se allineato ma manca sensore, giallo pulsante
                                    ctx.strokeStyle = '#FACC15';
                                }
                                ctx.beginPath();
                                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                    });
                });
            }
            requestAnimationFrame(drawLoop);
        }

        // Helper per centrare l'immagine nel canvas mantenendo aspect ratio
        function getDrawDimensions(cw, ch, img) {
            if (!img) return {x: 0, y: 0, w: 0, h: 0};
            const iw = img.naturalWidth;
            const ih = img.naturalHeight;
            const scale = Math.min(cw / iw, ch / ih);
            const w = iw * scale;
            const h = ih * scale;
            return {x: (cw - w) / 2, y: (ch - h) / 2, w: w, h: h};
        }

        function resizeCanvas() {
            if (video) {
                canvas.width = video.clientWidth;
                canvas.height = video.clientHeight;
            }
        }

        function updateUI() {
            document.getElementById('currentStepDisp').innerText = currentStep;
            const pct = ((currentStep - 1) / totalSteps) * 100;
            document.getElementById('progressBar').style.width = pct + '%';
        }
    </script>
{% endblock %}